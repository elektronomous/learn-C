we use copy or direct initialization matters if we use an initializer 
that requires conversion by an explicit constructor (dummyClass.cpp)

    vector<int> v1(10);             // direct initialization
    vector<int> v2 = 10;            // error: constructor that takes a size is explicit

    void f(vector<int>);            // f's parameter is copy initialized
    f(10);                          // error: can't use an explicit constructor to copy an argument
    f(vector<int>(10));             // ok: directly construct a temporary vector from an int

because the vector constructor that takes a single size parameter is
explicit. For the same reasons that we cannot copy initialize v2, we cannot
implicitly use an explicit constructor when we pass an argument or return a value
from a function. If we want to use an explicit constructor, we must do so
explicitly, as in the last line of the example above

The Compiler Can Bypass the Copy Constructor:
    During copy initialization, the compiler is permitted (but not obligated) to skip the
    copy/move constructor and create the object directly. That is, the compiler is
    permitted to rewrite:

        string null_book = "9999-99999";            // copy initialization
    
    into

        string null_book("9999-99999");             // compiler omits the copy constructor

    However, even if the compiler omits the call to the copy/move constructor, the
    copy/move constructor must exist and must be accessible (e.g., not private) at that
    point in the program.