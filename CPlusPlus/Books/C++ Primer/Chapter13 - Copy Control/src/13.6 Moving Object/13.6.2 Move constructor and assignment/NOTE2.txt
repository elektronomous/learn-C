As it does for the copy constructor and copy-assignment operator, the compiler will
synthesize the move constructor and move-assignment operator. However, the
conditions under which it synthesizes a move operation are quite different from those
in which it synthesizes a copy operation.

if a class defines its own copy constructor, copy-assignment operator, or destructor,
the move constructor and move-assignment operator are not synthesized. As a result,
some classes do not have a move constructor or a move-assignment operator. As we’ll
see on page 540, when a class doesn’t have a move operation, the corresponding copy
operation is used in place of move through normal function matching.

The compiler will synthesize a move constructor or a move-assignment operator
only if the class doesn’t define any of its own copy-control members and if every
nonstatic data member of the class can be moved. The compiler can move
members of built-in type. It can also move members of a class type if the member’s
class has the corresponding move operation:
        
        // the compiler will synthesize the move operations for X and hasX 
        struct X {
            int i;          // built-in types can be moved
            std::string s;  // string defines its own move operations
        };

        struct hasX {
            X mem;          // X has synthesized-move operations
        };

        X x, x2 = std::move(x);         // uses the synthesized-move constructor
        hasX hx, hx2 = std::move(hx)    // uses the synthesized move constructor

Unlike the copy operations, a move operation is never implicitly defined as a deleted
function. However, if we explicitly ask the compiler to generate a move operation by
using = default (§ 7.1.4, p. 264), and the compiler is unable to move all the
members, then the move operation will be defined as deleted. 

With one important exception, the rules for when a synthesized move operation is defined
as deleted are analogous to those for the copy operations (§ 13.1.6, p. 508):
    • Unlike the copy constructor, the move constructor is defined as deleted if the
      class has a member that defines its own copy constructor but does not also
      define a move constructor, or if the class has a member that doesn’t define its
      own copy operations and for which the compiler is unable to synthesize a move
      constructor. Similarly for move-assignment.
    • The move constructor or move-assignment operator is defined as deleted if the
      class has a member whose own move constructor or move-assignment operator
      is deleted or inaccessible.
    • Like the copy constructor, the move constructor is defined as deleted if the
      destructor is deleted or inaccessible.
    • Like the copy-assignment operator, the move-assignment operator is defined as
      deleted if the class has a const or reference member.
For example, assuming Y is a class that defines its own copy constructor but does not
also define its own move constructor:

        // assume Y is a class that defines its own copy constructor but not a move constructor
        struct hasY {
            hasY() = default;
            hasY(hasY&&) = default;
            Y mem;                      // hasY will have deleted move constructor
        };

        hasY hy, h2 = std::move(hy);    // Error: move constructor is deleted

The compiler can copy objects of type Y but cannot move them. Class hasY explicitly
requested a move constructor, which the compiler is unable to generate. Hence, hasY
will get a deleted move constructor. Had hasY omitted the declaration of its move
constructor, then the compiler would not synthesize the hasY move constructor at all.
The move operations are not synthesized if they would otherwise be defined as
deleted.

Classes that define a move constructor or move-assignment operator must also define their
own copy operations. Otherwise, those members are deleted by default.