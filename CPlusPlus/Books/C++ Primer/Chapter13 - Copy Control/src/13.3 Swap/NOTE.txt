in addition to defining the copy-control members, classes that manage resources
often also define a function named swap (§ 9.2.5, p. 339)

Defining swap is particularly important for classes that we plan to use with algorithms that reorder
elements (§ 10.2.3, p. 383). Such algorithms call swap whenever they need to exchange two elements

if a class defines its own swap, then the algorithm uses that class-specific version. 
Otherwise, it uses the swap function defined by the library.
it’s easy to see that swapping two objects involves a copy and two assignments.
For example, code to swap two objects of our valuelike HasPtr class (§ 13.2.1, p. 511) might look
something like (Library version/default behavior):

        HasPtr temp = v1;       // make a temporary value of v1
        v1 = v2;                // assign the value v2 to v1
        v2 = temp;              // assign the saved value of v1 to v2

This code copies the string that was originally in v1 twice—once when the HasPtr copy constructor
copies v1 into temp and again when the assignment operator assigns temp to v2. 
In principle, none of this memory allocation is necessary. That is, we’d like
swapping two HasPtrs to execute as:

        string *temp = v1.ps;   // make a temporary copy of the pointer in v1.ps
        v1.ps = v2.ps;          // assign the pointer in v2.ps to v1.ps
        v2.ps = temp;           // assign the saved pointer in v1.ps to v2.ps

We can override the default behavior of swap by defining a version of swap that
operates on our class. The typical implementation of swap is:

        class HasPtr {
            friend void swap(HasPtr&, HasPtr&);
            // other members as in 13.2.1
        };
        inline void swap(HasPtr &lhs, HasPtr &rhs) {
            using std::swap;
            swap(lhs.ps, rhs.ps);       // swap the pointers, not the string data
            swap(lhs.i, rhs.i);         // swap the int members
        }
We start by declaring swap as a friend to give it access to HasPtr’s (private)
data members. Because swap exists to optimize our code, we’ve defined swap as
an inline function (§ 6.5.2, p. 238). 

If you wonder which swap is called? Just take a read and you'll find it (p.798 -> 18.2.3)

In the HasPtr function, the data members have built-in types. There is no type-specific version of swap
for the built-in types. In this case, these calls will invoke the library std::swap.

However, if a class has a member that has its own type-specific swap function, calling std::swap in that
class would be a mistake. For example, assume we had another class named Foo that has a member named h,
which has type HasPtr:

    if we didn't write a Foo version of swap, then the library version of swap would be used. As we've
    already seen, the library swap makes unnecessary copies of the strings managed by HasPtr.

We can avoid these copies by writing a swap function for Foo. However, if we wrote the Foo version of swap as:
        
        void swap(Foo &lhs, Foo &rhs) {
            // WRONG: this function uses the library version of swap, not the HasPtr version
            std::swap(lhs.h, rhs.h);
            // swap other members of type Foo
        }

this code would compile and execute. However, there would be no performance difference between this code and
simply using the default version of swap. The problem is that we’ve explicitly requested the library version
of swap. However, we don’t want the version in std; we want the one defined for HasPtr objects. The right way
to write this swap function is: 

        void swap(Foo &lhs, Foo &rhs) {
            using std::swap;
            swap(lhs.h, rhs.h); // uses the HasPtr version of swap
            // swap other members of type Foo
        }

if there is a type-specific version of swap, that version will be a better match than the one defined in std.
If there is no type-specific version, then—assuming there is a using declaration for swap in scope—calls to swap
will use the version in std

Very careful readers may wonder why the using declaration inside swap does not hide the declarations for the HasPtr
version of swap (§ 6.4.1, p. 234). We’ll explain the reasons for why this code works in § 18.2.3 (p. 798)