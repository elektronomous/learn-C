For our HasPtr class to act like a pointer, we need the copy constructor and copy-
assignment operator to copy the pointer member, not the string to which that
pointer points. Our class will still need its own destructor to free the memory
allocated by the constructor that takes a string (§ 13.1.4, p. 504). In this case,
though, the destructor cannot unilaterally free its associated string. It can do so
only when the last HasPtr pointing to that string goes away

However, sometimes we want to manage a resource directly. In such cases, it
can be useful to use a reference count (§ 12.1.1, p. 452). To show how reference
counting works, we’ll redefine HasPtr to provide pointerlike behavior, but we
will do our own reference counting

Reference counting works as follows:
    • In addition to initializing the object, each constructor (other than the copy
      constructor) creates a counter. This counter will keep track of how many
      objects share state with the object we are creating. When we create an object,
      there is only one such object, so we initialize the counter to 1.
    • The copy constructor does not allocate a new counter; instead, it copies the
      data members of its given object, including the counter. The copy constructor
      increments this shared counter, indicating that there is another user of that
      object’s state.
    • The destructor decrements the counter, indicating that there is one less user
      of the shared state. If the count goes to zero, the destructor deletes that state.
    • The copy-assignment operator increments the right-hand operand’s counter
      and decrements the counter of the left-hand operand. If the counter for the
      left-hand operand goes to zero, there are no more users. In this case, the
      copy-assignment operator must destroy the state of the left-hand operand.