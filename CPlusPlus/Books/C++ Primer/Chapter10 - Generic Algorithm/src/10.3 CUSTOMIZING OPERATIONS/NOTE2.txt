When we define a lambda, the compiler generates a new (unnamed) class type that
corresponds to that lambda.

By default, the class generated from a lambda contains a data member corresponding to 
the variables captured by the lambda. Like the data members of any
class, the data members of a lambda are initialized when a lambda object is created.

If we capture a variable by reference, we must be certain
that the referenced object exists at the time the lambda is executed

Reference captures are sometimes necessary. For example, we might want our
biggies function to take a reference to an ostream on which to write and a
character to use as the separator

    vector<string> words;
    for_each(words.begin(), words.end(), [&os, c](const string &s) { cout << s << c; });

We can also return a lambda from a function. If the function returns a lambda, then—for
the same reasons that a function must not return a reference to a local variable—that lambda
must not contain reference captures.

The & tells the compiler to capture by reference, and the = says
the values are captured by value.
When we mix implicit and explicit captures, the first item in the capture list must
be an & or =. That symbol sets the default capture mode as by reference or by
value, respectively

hat is, if the implicit capture is by reference (using &),
then the explicitly named variables must be captured by value; hence their names
may not be preceded by an &. Alternatively, if the implicit capture is by value
(using =), then the explicitly named variables must be preceded by an & to indicate
that they are to be captured by reference.

The general form of a call to bind is:
    auto newCallable = bind(callable, arg_list);

where newCallable is itself a callable object and arg_list is a comma-separated list of
arguments that correspond to the parameters of the given callable. That is, when
we call newCallable, newCallable calls callable, passing the arguments in arg_list.

The arguments in arg_list may include names of the form _n, where n is an
integer. These arguments are “placeholders” representing the parameters of newCallable. 
They stand “in place of” the arguments that will be passed to newCallable.
The number n is the position of the parameter in the generated callable: _1 is the
first parameter in newCallable, _2 is the second, and so forth.

By default, the arguments to bind that are not placeholders are copied into the
callable object that bind returns.
because bind copies its arguments and we cannot copy an ostream. If we want
to pass an object to bind without copying it, we must use the library ref function

There is also a cref function that generates a class that holds a
reference to const. Like bind, the ref and cref functions are defined in the
functional header