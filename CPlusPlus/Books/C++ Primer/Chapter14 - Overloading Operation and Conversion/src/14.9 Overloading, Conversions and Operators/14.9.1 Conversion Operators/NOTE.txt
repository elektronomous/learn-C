A conversion operator is a special kind of member function that converts a value of a class
type to a value of some other type. A conversion function typically has the general form 
    
        operator type() const;

where type represents a type. Conversion operators can be defined for any type (other than 
void) that can be a function return type (§ 6.1, p. 204). Conversions to an array or a 
function type are not permitted. Conversions to pointer types—both data and function 
pointers—and to reference types are allowed. Conversion operators have no explicitly stated
return type and no parameters, and they must be defined as member functions. Conversion 
operations ordinarily should not change the object they are converting. As a result, 
conversion operators usually should be defined as const members.

As an example, we’ll define a small class that represents an integer in the range of
0 to 255:

        class SmallInt {
            public:
                SmallInt(int i = 0): val(i) {
                    if (i < 0 || i > 255)
                        throw std::out_of_range("Bad SmallInt value");
                }

                operator int() const { return val; }

            private:
                std::size_t val;
        };

Our SmallInt class defines conversions to and from its type. The constructor converts values
of arithmetic type to a SmallInt. The conversion operator converts SmallInt object to int:

        SmallInt si;
        si = 4;         // implicitly converts 4 to SmallInt then calls SmallInt::operator=
        si + 3;         // implicitly converts si to int followed by integer addition

Although the compiler will apply only one user-defined conversion at a time (§ 4.11.2, p. 162),
an implicit user-defined conversion can be preceded or followed by a standard (built-in) conversion
(§ 4.11.1, p. 159). As a result, we can pass any arithmetic type to the SmallInt constructor. 
Similarly, we can use the converion operator to convert a SmallInt to an int and then convert the
resulting int value to another arithmetic type:

        // the double argument is converted to int using the built-in conversion 
        SmallInt si = 3.14;     // calls the SmallInt(int) constructor

        // the SmallInt conversion operator converts si to int.
        si + 3.14;      // that int is converted to double using the built-in conversion

Although a conversion function does not specify a return type, each conversion function must return
a value of its corresponding type:
        
        class SmallInt;
        operator int(SmallInt&);        // Error: nonmember
        
        class SmallInt {
            public:
                int operator int() const;               // Error: return type
                operator int(int = 0) const;            // Error: parameter list
                operator int*() const { return 42; }    // Error: 42 is not a pointer
        };

CAUTION: AVOID OVERUSE OF CONVERSION FUNCTIONS
Conversion operators are misleading when there is no obvious single mapping between the class type
and the conversion type. For example, consider a class that represents a Date. We might think it 
would be a good idea to provide a conversion from Date to int. However, what value should the 
conversion function return? The function might return a decimal representation of the year, month,
and day. For example, July 30, 1989 might be represented as the int value 19800730. Alternatively, the
conversion operator might return an int representing the number of days that have elapsed since some 
epoch point, such as January 1, 1970. Both these conversions have the desirable property that later 
dates correspond to larger integers, and so either might be useful. The problem is that there is no 
single one-to-one mapping between an object of type Date and a value of type int. In such cases, it is
better not to define the conversion operator. Instead, the class ought to define one or more ordinary 
members to extract the information in these various forms.

(there is no single one-to-one mapping between an object of type Date and a value of type int.) means
you pass one argument and you get one value as the output. It turns out that Date class needs 3 argument
as the day, month and year.