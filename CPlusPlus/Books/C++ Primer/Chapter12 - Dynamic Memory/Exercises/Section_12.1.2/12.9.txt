Explain what happens in the following code:
    int *q = new int(42), *r = new int(100);
    r = q;

    auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
    r2 = q2;

(answer):
= In the first code, we allocated some memory of both *q and *r using new operator.
  After that we make the r to be pointed to the address in where q is pointed. Object
  pointed by r before it got change to point to object pointed by q is leak, because
  we don't free it.

= In the second code, we allocated some memory of both *q2 and *r2 using smart pointer.
  After that we make r2 to point to the object q2 pointed. This makes the r2 reference count
  decremented because when we assign to smart pointer another address, the reference count
  is decremented by 1. Since the address pointed by r2 is only r2, the decremented will result 0
  which makes the smart pointer to free itself.