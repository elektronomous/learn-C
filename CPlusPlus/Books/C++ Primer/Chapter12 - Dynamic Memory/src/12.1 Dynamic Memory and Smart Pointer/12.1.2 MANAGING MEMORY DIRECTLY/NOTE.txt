By default, dynamically allocated objects are default initialized (§ 2.2.1, p. 43),
which means that objects of built-in or compound type have undefined value; objects
of class type are initialized by their default constructor:

new expression constructs an object of type int on the free store and returns a
pointer to that object.

We can initialize a dynamically allocated object using direct initialization (§ 3.2.1, p.
84). We can use traditional construction (using parentheses), and under the new
standard, we can also use list initialization (with curly braces)

    string *ps1 = new string;   // default initialized to the empty string
    string *ps = new string();  // value initialized to the empty string
    int *pi1 = new int;         // default initialized; *pi1 is undefined
    int *pi2 = new int();       // value initialized to 0; *pi2 is 0

it is also a good idea to initialize dynamically allocated objects

When we provide an initializer inside parentheses, we can use auto (§ 2.5.2, p. 68)
to deduce the type of the object we want to allocate from that initializer. However,
because the compiler uses the initializer’s type to deduce the type to allocate, we can
use auto only with a single initializer inside parentheses:
    auto p1 = new auto(obj);    // p points to an object of the type of obj
                                // that object is initialized from obj
    auto p2 = new auto{a,b,c};  // error: must use parentheses for the initializer

The type of p1 is a pointer to the auto-deduced type of obj. If obj is an int, then
p1 is int*; if obj is a string, then p1 is a string*; and so on. The newly
allocated object is initialized from the value of obj

It is legal to use new to allocate const objects. Like any other const, a dynamically 
allocated const object must be initialized. A const dynamic object of a class type that 
defines a default constructor (§ 7.1.4, p. 263) may be initialized implicitly. Objects 
of other types must be explicitly initialized. Because the allocated object is const, 
the pointer returned by new is a pointer to const (§ 2.4.2, p. 62)

By default, if new is unable to allocate the requested storage, it throws an exception
of type bad_alloc (§ 5.6, p. 193). We can prevent new from throwing an exception by using 
a different form of new. When we pass nothrow to new, we tell new that it must not throw 
an exception. If this form of new is unable to allocate the requested storage, it will 
return a null pointer. Both bad_alloc and nothrow are defined in the new header

a delete expression performs two actions: It destroys the object to which its given pointer 
points, and it frees the corresponding memory

The pointer we pass to delete must either point to dynamically allocated memory or
be a null pointer (§ 2.3.2, p. 53). Deleting a pointer to memory that was not allocated
by new, or deleting the same pointer value more than once, is undefined