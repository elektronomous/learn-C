For the set types, the key_type and the value_type are the same; the values
held in a set are the keys. In a map, the elements are key–value pairs. That is,
each element is a pair object containing a key and a associated value. Because we
cannot change an element’s key, the key part of these pairs is const

    set<string>::value_type v1;             // v1 is a string
    set<string>::key_type v2;               // v2 is a string
    map<string, int>::value_type v3;        // v3 is pair<const string, int>
    map<string, int>::key_type v4;          // v4 is a string
    map<string, int>::mapped_type v5;       // v5 is an int

Only the map types (unordered_map, unordered_multimap, multimap,
and map) define mapped_type

It is essential to remember that the value_type of a map is a pair and
that we can change the value but not the key member of that pair

Although the set types define both the iterator and const_iterator types,
both types of iterators give us read-only access to the elements in the set. Just as
we cannot change the key part of a map element, the keys in a set are also const

 we do not use the generic algorithms (Chapter 10) with the associative
containers. The fact that the keys are const means that we cannot pass associative
container iterators to algorithms that write to or reorder container elements. Such
algorithms need to write to the elements. The elements in the set types are const,
and those in maps are pairs whose first element is const

Because elements in an associative container can be found (quickly) by their key, it is almost always a bad
idea to use a generic search algorithm. We use find member defined by the associative container

we might use the generic copy algorithm to copy the elements from an associative container
into another sequence.
Similarly, we can call inserter to bind an insert iterator (§ 10.4.1, p. 401) to an associative container.

c.insert(v)
c.emplace(args)     v value_type object; args are used to construct an element.
                    For map and set, the element is inserted (or constructed) only if an
                    element with the given key is not already in c. Returns a pair containing an iterator referring to the element with the given key and a
                    bool indicating whether the element was inserted.
                    For multimap and multiset, inserts (or constructs) the given element and returns an iterator to the new element.
c.insert(b, e)
c.insert(il)        b and e are iterators that denote a range of c::value_type values;
                    il is a braced list of such values. Returns void.
                    For map and set, inserts the elements with keys that are not already
                    in c. For multimap and multiset inserts, each element in the range.
c.insert(p, v)
c.emplace(p, args)
                    Like insert(v) (or emplace(args)), but uses iterator p as a hint
                    for where to begin the search for where the new element should be
                    stored. Returns an iterator to the element with the given key.

The value returned by insert (or emplace) depends on the container type and
the parameters

= inserting on MAP, SET
The first member of the pair is an iterator to the element with the given key; 
the second is a bool indicating whether that element was inserted, or was already there. 
If the key is already in the container, then insert does nothing, and the bool portion of 
the return value is false. If the key isn’t present, then the element is inserted and the bool is true

= inserting on MULTIMAP, MULTISET
For the containers that allow multiple keys, the insert operation that takes a
single element returns an iterator to the new element. There is no need to return a
bool, because insert always adds a new element in these types.