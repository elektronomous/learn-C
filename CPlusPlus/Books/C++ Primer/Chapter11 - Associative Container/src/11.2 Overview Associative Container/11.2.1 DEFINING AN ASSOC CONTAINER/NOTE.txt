Each of the associative containers defines a default constructor, which creates
an empty container of the specified type. We can also initialize an associative
container as a copy of another container of the same type or from a range of values,
so long as those values can be converted to the type of the container.

initialize map elements:

    map<string, size_t> word_count; // empty
    set<string> exclude = {"the", "but, "and", "or", "an", "a", "The", "But",
                           "And", "Or", "An", "A"};

    // three elements; authors maps last name to first
    map<string, string> authors { {"Joyce", "James"},
                                  {"Austen", "Jane"},
                                  {"Dickens", "Charles"}
                                };

When we initialize a map, we have to supply both the key and the value. We wrap
each key–value pair inside curly braces:
    {key, value}
to indicate that the items together form one element in the map.

The keys in a map or a set must be unique; there can be only one element with a
given key. The multimap and multiset containers have no such restriction; there
can be several elements with the same key. 

For the ordered containers—map, multimap, set, and multiset—the key type must define a way 
to compare the elements. By default, the library uses the < operator for
the key type to compare the keys. In the set types, the key is the element type; in the
map types, the key is the first type. Thus, the key type for word_count in § 11.1 (p.
421) is string. Similarly, the key type for exclude is string.

Just as we can provide our own comparison operation to an algorithm (§ 10.3, p.
385), we can also supply our own operation to use in place of the < operator on keys.
The specified operation must define a strict weak ordering over the key type. We
can think of a strict weak ordering as “less than,” although our function might use a
more complicated procedure. However we define it, the comparison function must
have the following properties:

    • Two keys cannot both be “less than” each other; if k1 is “less than” k2, then
    k2 must never be “less than” k1.
    • If k1 is “less than” k2 and k2 is “less than” k3, then k1 must be “less than”
    k3.
    • If there are two keys, and neither key is “less than” the other, then we’ll say
    that those keys are “equivalent.” If k1 is “equivalent” to k2 and k2 is
    “equivalent” to k3, then k1 must be “equivalent” to k3

The type of the operation that a container uses to organize its elements is part of the
type of that container.
To specify our own operation, we must supply the type of that operation when we define 
the type of an associative container. The operation type is specified following the element 
type inside the angle brackets that we use to say which type of container we are defining.

Each type inside the angle brackets is just that, a type. We supply a particular
comparison operation (that must have the same type as we specified inside the angle
brackets) as a constructor argument when we create a container.


    multiset<Sales_data, decltype(compareIsbn)*> bookStore(compareIsbn);

For example, we can’t directly define a multiset of Sales_data because
Sales_data doesn’t have a < operator. However, we can use the compareIsbn
function from the exercises in § 10.3.1 (p. 387) to define a multiset. That function
defines a strict weak ordering based on their ISBNs of two given Sales_data objects.
The compareIsbn function should look something like
    